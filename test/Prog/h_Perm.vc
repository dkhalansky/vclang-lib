\open ::Data::Nat::Base
\open ::Prog::g_Bijection
\open ::Sets
\open ::PropLogic
\open ::Equiv
\open ::Combinators
\open ::Paths
\open ::Hlevel
\open ::Data::Fin
\open ::Data::Fin::Properties
\open ::Data::Either
\open ::Data::Nat::Compare
\open ::Data::Nat::Properties
\open ::Relation
\open ::Data::Empty
\open ::Data::Unit
\open ::Data::Bool

-- Permutation group

\function isPerm {A : \Set} (f : A -> A) : \Set => isBij f

\function permCompIsPerm {A : \Set} (f : A -> A) (g : A -> A) (fp : isPerm f) (gp : isPerm g) : isPerm (g `o f) => bijCompIsBij f g fp gp

\function permIdentity {A : \Set} : \Sigma (f : A -> A) (isBij f) => (id, (id, (idp, idp)))

\function permInverse {A : \Set} (f : A -> A) (fp : isPerm f) : \Sigma (g : A -> A) (isPerm g) => (fp.1, (f, (fp.2.2, fp.2.1)))

-- Finiteness

\function subsetIsFinite {A : \Set} (B : A -> \Prop) (n : Nat) : \Prop => exists (\lam (f : Fin n -> (\Sigma (a : A) (B a))) => isSurj f)

\function isPermSupport {A : \Set} (f : A -> A) (B : A -> \Prop) : \Prop => \Pi (a : A) -> B a ||| (f a = a)

-- Finite permutation group

\function finitePerm {A : \Set} (f : A -> A) : \Set => \Sigma (isPerm f) (\Sigma (n : Nat) (exists (\lam B => isPermSupport f B &&& subsetIsFinite B n)))

\function Le-is-addition (a b : Nat) (g : a `Le b) : \Sigma (c : Nat) (b = a + c) => \elim a, b, g
  | zero, b, _ => (b, idp)
  | suc a, suc b, le_ss p => \let res => Le-is-addition a b p \in (res.1, pmap suc res.2)

\function plus-minus-inv (a b : Nat) : b + a - b = a => \elim b
  | zero => idp
  | suc b' => pred-suc-minus (b' + a) b' *> plus-minus-inv a b'

\function pred-suc-inv (n : Nat) : pred (suc n) = n => \elim n
  | zero => idp
  | suc n' => idp

\function eq-unsuc {a b : Nat} (p : suc a = suc b) : a = b => inv (pred-suc-inv a) *> pmap pred p *> pred-suc-inv b

\function minus-remove-suc {n m : Nat} : (suc n - suc m = n - m) => pred-suc-minus n m

\function fin-bounded {n : Nat} (fn : Fin n) : to-nat fn `Lt n => \elim n, fn
  | suc n', fzero => le_ss le_z
  | suc n', fsuc fn' => le_ss (fin-bounded fn')

\function fin-minus-helper {n o : Nat} (p : (n + o) `Lt (n + 0)) : Empty => \elim n
  | zero => suc_nle_zero p
  | suc n => fin-minus-helper (Le_unsuc p)

\function fin-minus (n m o : Nat) (a : Fin (n + m)) (p : to-nat a = n + o) : \Sigma (c : Fin m) (to-nat c = o) => \elim n, m, a
  | zero,   suc m', fzero => (fzero {m'}, p)
  | suc n', zero,   fzero => absurd (zero-ne-suc p)
  | suc n', suc m', fzero => absurd (zero-ne-suc p)
  | zero,   suc m', fsuc a' => (fsuc {m'} a', p)
  | suc n', zero,   fsuc a' => absurd (fin-minus-helper (transport (\lam x => x `Le (n' + 0)) p (fin-bounded a')))
  | suc n', suc m', fsuc a' => fin-minus n' (suc m') o a' (eq-unsuc p)

\function fin-transport-id {n m : Nat} (f : Fin n) (p : n = m) : to-nat f = to-nat (transport Fin p f) =>
  {?}

\function fin-precise (n m : Nat) (p : n `Gt m) : \Sigma (c : Fin n) (m = to-nat c) =>
  \let res => Le-is-addition (suc m) n p
     | f   => flift res.1 (from-nat m)
   \in (transport Fin (inv res.2) f, inv (from-to-id m) *> flift-id res.1 (from-nat m) *> fin-transport-id f (inv res.2))

\function plus-comm1 (n m : Nat) : suc (n + m) = n + suc m =>
  pmap suc (plus-comm n m) *> plus-comm (suc m) n

{-
\function fin-partition (n m : Nat) (f : Fin (n + m)) : Either (Fin n) (Fin m) =>
  \case cmp n (to-nat a) \with {
    | tri_lt p _ _ => {?}
    | tri_eq _ p _ => {?}
    | tri_gt _ _ p => {?}
  }
-}

\function finiteCompIsFinite {A : \Set} (f : A -> A) (g : A -> A) (ff : finitePerm f) (gf : finitePerm g) : finitePerm (g `o f) =>
  (permCompIsPerm f g ff.1 gf.1, (ff.2.1 + gf.2.1, \case ff.2.2 \with { inP Bf => \case gf.2.2 \with { inP Bg =>
    inP (\lam a => Bf.1 a ||| Bg.1 a, (\lam a => \case Bf.2.1 a \with { inP bfs => \case Bg.2.1 a \with { inP bgs =>
      inP (\case bfs \with {
        | inl bfsa => inl (inP (inl bfsa))
        | inr fp => \case bgs \with {
          | inl bgsa => inl (inP (inr bgsa))
          | inr gp => inr (pmap g fp *> gp)
        }
      })
    }}, \case Bf.2.2 \with { inP bffn => \case Bg.2.2 \with { inP bgfn => 
      inP ((\lam a => \case cmp ff.2.1 (to-nat a) \with {
        | tri_lt p _ _ => \let | ad => Le-is-addition (1 + ff.2.1) (to-nat a) p
                               | arg => fin-minus ff.2.1 gf.2.1 (1 + ad.1) a (ad.2 *> plus-comm1 ff.2.1 ad.1)
                               | res => bgfn.1 arg.1
                           \in (res.1, inP (inr res.2))
        | tri_eq _ p _ => \let | arg => fin-minus ff.2.1 gf.2.1 0 a (inv p *> plus-comm0 ff.2.1)
                               | res => bgfn.1 arg.1
                           \in (res.1, inP (inr res.2))
        | tri_gt _ _ p => \let | arg => fin-precise ff.2.1 (to-nat a) p
                               | res => bffn.1 arg.1
                           \in (res.1, inP (inl res.2))
      }), \lam a => \case a.2 \with {
        | inP (inl p) => inP-map (\lam pf => {?}) (bffn.2 (a.1, p))
        | inP (inr p) => inP-map (\lam pf => {?}) (bgfn.2 (a.1, p))
      })
    }}))
  }}))

\function finiteIdentity {A : \Set} : \Sigma (f : A -> A) (finitePerm f) =>
  (id, ((id, (idp, idp)), (0, inP ((\lam a => False), (\lam a => inP (inr idp), inP (\lam a => \case a \with {}, \lam b => \case b.2 \with {}))))))

\function inP-map {A B : \Type} (f : A -> B) (a : TrP A) : TrP B => \elim a
  | inP v => inP (f v)

\function finiteInverse {A : \Set} (f : A -> A) (ff : finitePerm f) : \Sigma (g : A -> A) (finitePerm g) =>
  ((permInverse f ff.1).1, ((permInverse f ff.1).2, (ff.2.1, \case ff.2.2 \with {
    inP Bp => inP (Bp.1, (\lam a => inP-map (map-inr (\lam p => inv (pmap ff.1.1 p) *> fun-ext-inv ff.1.2.2 a)) (Bp.2.1 a), Bp.2.2))
  })))
