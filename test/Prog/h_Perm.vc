\open ::Data::Nat::Base
\open ::Prog::g_Bijection
\open ::Sets
\open ::PropLogic
\open ::Equiv
\open ::Combinators
\open ::Paths
\open ::Hlevel
\open ::Data::Fin
\open ::Data::Fin::Properties
\open ::Data::Either
\open ::Data::Nat::Compare
\open ::Data::Nat::Properties
\open ::Relation
\open ::Data::Empty
\open ::Data::Unit
\open ::Data::Bool
\open ::Logic

-- Permutation group

\function isPerm {A : \Set} (f : A -> A) : \Set => isBij f

\function permCompIsPerm {A : \Set} (f : A -> A) (g : A -> A) (fp : isPerm f) (gp : isPerm g) : isPerm (g `o f) => bijCompIsBij f g fp gp

\function permIdentity {A : \Set} : \Sigma (f : A -> A) (isBij f) => (id, (id, (idp, idp)))

\function permInverse {A : \Set} (f : A -> A) (fp : isPerm f) : \Sigma (g : A -> A) (isPerm g) => (fp.1, (f, (fp.2.2, fp.2.1)))

-- Finiteness

\function subsetIsFinite {A : \Set} (B : A -> \Prop) (n : Nat) : \Prop => exists (\lam (f : Fin n -> (\Sigma (a : A) (B a))) => isSurj f)

\function isPermSupport {A : \Set} (f : A -> A) (B : A -> \Prop) : \Prop => \Pi (a : A) -> B a ||| (f a = a)

-- Finite permutation group

\function finitePerm {A : \Set} (f : A -> A) : \Set => \Sigma (isPerm f) (\Sigma (n : Nat) (exists (\lam B => isPermSupport f B &&& subsetIsFinite B n)))

\function Le-is-addition (a b : Nat) (g : a `Le b) : \Sigma (c : Nat) (b = a + c) => \elim a, b, g
  | zero, b, _ => (b, idp)
  | suc a, suc b, le_ss p => \let res => Le-is-addition a b p \in (res.1, pmap suc res.2)

\function plus-minus-inv (a b : Nat) : b + a - b = a => \elim b
  | zero => idp
  | suc b' => pred-suc-minus (b' + a) b' *> plus-minus-inv a b'

\function pred-suc-inv (n : Nat) : pred (suc n) = n => \elim n
  | zero => idp
  | suc n' => idp

\function eq-unsuc {a b : Nat} (p : suc a = suc b) : a = b => inv (pred-suc-inv a) *> pmap pred p *> pred-suc-inv b

\function minus-remove-suc {n m : Nat} : (suc n - suc m = n - m) => pred-suc-minus n m

\function fin-bounded {n : Nat} (fn : Fin n) : to-nat fn `Lt n => \elim n, fn
  | suc n', fzero => le_ss le_z
  | suc n', fsuc fn' => le_ss (fin-bounded fn')

\function fin-minus-helper {n o : Nat} (p : (n + o) `Lt (n + 0)) : Empty => \elim n
  | zero => suc_nle_zero p
  | suc n => fin-minus-helper (Le_unsuc p)

\function fin-minus {n m o : Nat} (a : Fin (n + m)) (p : to-nat a = n + o) : \Sigma (c : Fin m) (to-nat c = o) => \elim n, m, a
  | zero,   suc m', fzero => (fzero {m'}, p)
  | suc n', zero,   fzero => absurd (zero-ne-suc p)
  | suc n', suc m', fzero => absurd (zero-ne-suc p)
  | zero,   suc m', fsuc a' => (fsuc {m'} a', p)
  | suc n', zero,   fsuc a' => absurd (fin-minus-helper (transport (\lam x => x `Le (n' + 0)) p (fin-bounded a')))
  | suc n', suc m', fsuc a' => fin-minus a' (eq-unsuc p)

\function fin-precise {n m : Nat} (p : n `Gt m) : \Sigma (c : Fin n) (m = to-nat c) => \elim n, m
  | zero, _ => absurd (suc_nle_zero p)
  | suc n, zero  => (fzero, idp)
  | suc n, suc m => \let z => fin-precise (Le_unsuc p)
                     \in (fsuc z.1, pmap suc z.2)

\function plus-comm1 (n m : Nat) : suc (n + m) = n + suc m =>
  pmap suc (plus-comm n m) *> plus-comm (suc m) n

\function nlt-ge {n m : Nat} (p : Not (n `Lt m)) : m `Le n => \elim n, m
  | zero, zero  => le_z
  | suc n, zero => le_z
  | zero, suc m => absurd (p (le_ss le_z))
  | suc n, suc m => le_ss (nlt-ge (\lam nltm => p (le_ss nltm)))

\function lt-le {n m : Nat} (p : n `Lt m) : n `Le m => \elim n, m
  | zero,  suc m => le_z
  | suc n, suc m => le_ss (lt-le (Le_unsuc p))
  | zero,  zero  => absurd (suc_nle_zero p)
  | suc n, zero  => absurd (suc_nle_zero p)

\function fin-partition-helper {n m : Nat} {a : Fin (n + m)} (d : Dec (to-nat a `Lt n)) : Either (Fin n) (Fin m) => \elim d
  | inl p => inr (fin-minus a (Le-is-addition n (to-nat a) (nlt-ge p)).2).1
  | inr p => inl (fin-precise p).1

\function fin-partition {n m : Nat} (a : Fin (n + m)) : Either (Fin n) (Fin m) => fin-partition-helper (Lt-dec (to-nat a) n)

\function fin-departition {n m : Nat} (a : Either (Fin n) (Fin m)) : Fin (n + m) => \elim a
  | inl p => flift m p
  | inr p => fadd n p

\function either-helper {A B : \Type} (d : Either A B) : Either (\Sigma (a : A) (d = inl a)) (\Sigma (b : B) (d = inr b)) => \elim d
  | inl a => inl (a, idp)
  | inr a => inr (a, idp)

\function fin-partition-isSurj {n m : Nat} : isSurj (fin-partition {n} {m}) =>
  \lam b => inP (fin-departition b, inP (
    \case either-helper b \with {
      | inl p => transport (\lam c => (fin-partition (fin-departition c)) = c) (inv p.2) (
          \case either-helper (Lt-dec (to-nat (flift m p.1)) n) \with {
            | inl ct => absurd (ct.1 (transport (\lam tnt => tnt `Lt n) (flift-id m p.1) (fin-bounded p.1)))
            | inr pf => pmap fin-partition-helper pf.2 *> pmap inl {?}
          })
      | inr p => {?}
    }
  ))

{-
\function finiteCompIsFinite {A : \Set} (f : A -> A) (g : A -> A) (ff : finitePerm f) (gf : finitePerm g) : finitePerm (g `o f) =>
  (permCompIsPerm f g ff.1 gf.1, (ff.2.1 + gf.2.1, \case ff.2.2 \with { inP Bf => \case gf.2.2 \with { inP Bg =>
    inP (\lam a => Bf.1 a ||| Bg.1 a, (\lam a => \case Bf.2.1 a \with { inP bfs => \case Bg.2.1 a \with { inP bgs =>
      inP (\case bfs \with {
        | inl bfsa => inl (inP (inl bfsa))
        | inr fp => \case bgs \with {
          | inl bgsa => inl (inP (inr bgsa))
          | inr gp => inr (pmap g fp *> gp)
        }
      })
    }}, \case Bf.2.2 \with { inP bffn => \case Bg.2.2 \with { inP bgfn => 
      inP ((\lam a => \case cmp ff.2.1 (to-nat a) \with {
        | tri_lt p _ _ => \let | ad => Le-is-addition (1 + ff.2.1) (to-nat a) p
                               | arg => fin-minus ff.2.1 gf.2.1 (1 + ad.1) a (ad.2 *> plus-comm1 ff.2.1 ad.1)
                               | res => bgfn.1 arg.1
                           \in (res.1, inP (inr res.2))
        | tri_eq _ p _ => \let | arg => fin-minus ff.2.1 gf.2.1 0 a (inv p *> plus-comm0 ff.2.1)
                               | res => bgfn.1 arg.1
                           \in (res.1, inP (inr res.2))
        | tri_gt _ _ p => \let | arg => fin-precise ff.2.1 (to-nat a) p
                               | res => bffn.1 arg.1
                           \in (res.1, inP (inl res.2))
      }), \lam a => \case a.2 \with {
        | inP (inl p) => inP-map (\lam pf => {?}) (bffn.2 (a.1, p))
        | inP (inr p) => inP-map (\lam pf => {?}) (bgfn.2 (a.1, p))
      })
    }}))
  }}))
-}

\function finiteIdentity {A : \Set} : \Sigma (f : A -> A) (finitePerm f) =>
  (id, ((id, (idp, idp)), (0, inP ((\lam a => False), (\lam a => inP (inr idp), inP (\lam a => \case a \with {}, \lam b => \case b.2 \with {}))))))

\function inP-map {A B : \Type} (f : A -> B) (a : TrP A) : TrP B => \elim a
  | inP v => inP (f v)

\function finiteInverse {A : \Set} (f : A -> A) (ff : finitePerm f) : \Sigma (g : A -> A) (finitePerm g) =>
  ((permInverse f ff.1).1, ((permInverse f ff.1).2, (ff.2.1, \case ff.2.2 \with {
    inP Bp => inP (Bp.1, (\lam a => inP-map (map-inr (\lam p => inv (pmap ff.1.1 p) *> fun-ext-inv ff.1.2.2 a)) (Bp.2.1 a), Bp.2.2))
  })))
